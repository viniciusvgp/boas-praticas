# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+STARTUP: overview indent
#+LANGUAGE: pt_BR
#+OPTIONS:   toc:nil
#+TAGS: noexport(n) deprecated(d) ignore(i)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+TITLE:     Análise de dados
#+AUTHOR:    Lucas Mello Schnorr, Vinícius Garcia Pinto
#+EMAIL:     {schnorr, vgpinto}@inf.ufrgs.br

* #3.0 Passos iniciais

Execute os tutoriais precedentes nesta série:
- [[./0_Programa_Teste.org][#0 (Programa Teste)]]
- [[./1_Ferramentas.org][#1 (Ferramentas)]]
- [[./1_Experimentos.org][#2 (Experimentos)]]

Ou, utilize [[./exp0.tgz][este arquivo que foi previamente coletado]].

* #3.1 Local/Container Parsing para extração de informações

No container, vamos criar um CSV com informações das medidas.

A primeira coluna será a chave, a segunda o tempo.

Nome sugerido para o CSV: =resultados.csv=.

#+begin_src shell :results output
tar xfz exp0.tgz
for file in exp0/*.log; do
  KEY=$(basename $file .log)
  TIME=$(cat $file | grep Execution | sed "s/.*://")
  echo $KEY, $TIME
done > resultados.csv
cat resultados.csv
#+end_src

#+RESULTS:
#+begin_example
10-2-400, 3.931268
11-2-300, 1.954268
1-20-400,
12-10-400, 1.252950
13-2-400, 4.108260
14-10-400, 1.111597
15-20-400, 1.140633
16-10-300, 0.571220
17-2-300, 1.949823
18-20-300, 0.791935
2-2-400, 3.919913
3-20-300, 0.793258
4-10-400, 1.254441
5-10-300, 0.496930
6-2-300, 1.953920
7-20-400, 1.158824
8-20-300, 0.811984
9-10-300, 0.646577
#+end_example

Os dados acima estão estranho, pois está faltando uma medida.

Vamos olhar o log da execução que ficou estranho.

#+begin_src shell :results output
cat exp0/1-20-400.log
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------
Open MPI tried to fork a new process via the "execve" system call but
failed.  Open MPI checks many things before attempting to launch a
child process, but nothing is perfect. This error may be indicative
of another problem on the target host, or even something as silly as
having specified a directory for your application. Your job will now
abort.

  Local host:        tupi2
  Application name:  ./mpi_mm
  Error:             Stale file handle
--------------------------------------------------------------------------
--------------------------------------------------------------------------
[[57280,1],1]: A high-performance Open MPI point-to-point messaging module
was unable to find any relevant network interfaces:

Module: OpenFabrics (openib)
  Host: tupi1

Another transport will be used instead, although this may result in
lower performance.

NOTE: You can disable this warning by setting the MCA parameter
btl_base_warn_component_unused to 0.
--------------------------------------------------------------------------
--------------------------------------------------------------------------
mpirun noticed that process rank 10 with PID 11724 on node tupi2 exited on signal 85 (Unknown signal 85).
--------------------------------------------------------------------------
9 total processes failed to start
#+end_example

Ahh, usamos NFS.

Entao vamos em frente mesmo assim.

* #3.2 Local/Container Leitura em R

No container, lance um processo R no diretório onde foi gravado o
arquivo =resultados.csv=, para tal, basta:

#+begin_src R :results output :session :exports both
R
#+end_src

A partir de agora, todos os comandos são no /shell/ do R.

Carregue o meta-pacote tidyverse com todas as demais funções que
precisamos.

#+begin_src R :results output :session :exports both
library(tidyverse)
#+end_src

#+RESULTS:

Vamos ler o arquivo CSV

#+begin_src R :results output :session :exports both
df <- read_csv("resultados.csv", col_names=FALSE)
df
#+end_src

#+RESULTS:
#+begin_example
Parsed with column specification:
cols(
  X1 = col_character(),
  X2 = col_double()
)

# A tibble: 18 x 2
   X1            X2
   <chr>      <dbl>
 1 10-2-400   3.93 
 2 11-2-300   1.95 
 3 1-20-400  NA    
 4 12-10-400  1.25 
 5 13-2-400   4.11 
 6 14-10-400  1.11 
 7 15-20-400  1.14 
 8 16-10-300  0.571
 9 17-2-300   1.95 
10 18-20-300  0.792
11 2-2-400    3.92 
12 3-20-300   0.793
13 4-10-400   1.25 
14 5-10-300   0.497
15 6-2-300    1.95 
16 7-20-400   1.16 
17 8-20-300   0.812
18 9-10-300   0.647
#+end_example

Vamos realizar uma transformação de dados:
- =separate= para separar a primeira coluna em três colunas
- =mutate= para recalcular as colunas com valores inteiros
- =rename= para renomear uma coluna
- =filter= para filtrar somente linhas que respeitam uma condição
- =group_by= para criar grupos sobre os quais as próximas operações se aplicaram
- =summarize= para transformar todas as linhas de um grupo em uma linha

#+begin_src R :results output :session :exports both
df %>%
    separate(X1, into=c("Name", "Processes", "Size")) %>%
    mutate(Processes = as.integer(Processes),
           Size = as.integer(Size)) %>%
    rename(Time = X2) %>%
    filter(!is.na(Time)) %>%
    group_by(Processes, Size) %>%
    summarize(N=n(),
              Média = mean(Time, na.rm=TRUE),
              Erro = 3*sd(Time)/sqrt(N)) -> df.0
df.0
#+end_src

#+RESULTS:
#+begin_example

# A tibble: 6 x 5
# Groups:   Processes [3]
  Processes  Size     N Média    Erro
      <int> <int> <int> <dbl>   <dbl>
1         2   300     3 1.95  0.00428
2         2   400     3 3.99  0.183  
3        10   300     3 0.572 0.130  
4        10   400     3 1.21  0.142  
5        20   300     3 0.799 0.0194 
6        20   400     2 1.15  0.0273
#+end_example

Vamos agora criar o gráfico:
- as cores se referem ao tamanho
- o ponto é baseado no média
- as barras de erro em função do erro (assumindo distrib. gaussiana)

#+begin_src R :results output graphics :file img/grafico1.png :exports both :width 600 :height 400 :session
df.0 %>%
    ggplot(aes(x = Processes, y = Média, color=as.factor(Size))) +
    theme_bw(base_size = 25) +
    geom_point(size=3) +
    geom_errorbar(aes(ymin = Média - Erro,
                      ymax = Média + Erro), width=.5) +
    ylim(0,NA)
#+end_src

#+RESULTS:
[[file:img/grafico1.png]]

Uma segunda versão com facetas:
- veja o =facet_wrap=, baseado em uma coluna

#+begin_src R :results output graphics :file img/grafico2.png :exports both :width 600 :height 400 :session
df.0 %>%
    ggplot(aes(x = Processes, y = Média, color=as.factor(Size))) +
    theme_bw(base_size = 25) +
    geom_point(size=3) +
    geom_errorbar(aes(ymin = Média - Erro,
                      ymax = Média + Erro), width=.5) +
    ylim(0,NA) +
    facet_wrap(~Size)
#+end_src

#+RESULTS:
[[file:img/grafico2.png]]

* Old                                                              :noexport:

# R + tidyverse
Uma vez concluídas as execuções, inciaremos a etapa de análise dos
dados. A aplicação ~BT-MZ~ gera como saída arquivos texto no formato do
exemplo abaixo:

#+begin_src shell :results output :exports results
cat btmz-12-2-2-W.log
#+end_src

#+RESULTS:
#+begin_example


 NAS Parallel Benchmarks (NPB3.4-MZ MPI+OpenMP) - BT-MZ Benchmark

 Number of zones:   4 x   4
 Total mesh size:    64 x    64 x   8
 Iterations: 200    dt:   0.000800
 Number of active processes:      2

 Use the default load factors
 Total number of threads:      4  (  2.0 threads/process)

 Calculated speedup =      3.97

 Time step    1
 Time step   20
 Time step   40
 Time step   60
 Time step   80
 Time step  100
 Time step  120
 Time step  140
 Time step  160
 Time step  180
 Time step  200
 Verification being performed for class W
 accuracy setting for epsilon =  0.1000000000000E-07
 Comparison of RMS-norms of residual
           1 0.5562611195402E+05 0.5562611195402E+05 0.2275939447133E-13
           2 0.5151404119932E+04 0.5151404119932E+04 0.3177949982330E-13
           3 0.1080453907954E+05 0.1080453907954E+05 0.4318284922427E-12
           4 0.6576058591929E+04 0.6576058591929E+04 0.2074558846440E-13
           5 0.4528609293561E+05 0.4528609293561E+05 0.3100863263992E-13
 Comparison of RMS-norms of solution error
           1 0.7185154786403E+04 0.7185154786403E+04 0.4974582015591E-13
           2 0.7040472738068E+03 0.7040472738068E+03 0.3294113301485E-13
           3 0.1437035074443E+04 0.1437035074443E+04 0.1886032052721E-12
           4 0.8570666307849E+03 0.8570666307849E+03 0.3117191348368E-13
           5 0.5991235147368E+04 0.5991235147368E+04 0.6755287220979E-13
 Verification Successful


 BT-MZ Benchmark Completed.
 Class           =                        W
 Size            =             64x   64x  8
 Iterations      =                      200
 Time in seconds =                     2.28
 Total processes =                        2
 Total threads   =                        4
 Mop/s total     =                  6284.26
 Mop/s/thread    =                  1571.07
 Operation type  =           floating point
 Verification    =               SUCCESSFUL
 Version         =                      3.4
 Compile date    =              07 Apr 2019

 Compile options:
    FC           = mpif90
    FLINK        = $(FC)
    F_LIB        = (none)
    F_INC        = (none)
    FFLAGS       = -O3 -fopenmp
    FLINKFLAGS   = $(FFLAGS)
    RAND         = (none)


 Please send all errors/feedbacks to:

 NPB Development Team
 npb@nas.nasa.gov


#+end_example

Esta saída é bastante completa e contém varias informações como os
parâmetros utilizados na execução e as verificações de erro. Neste
tutorial, para efeitos de demonstração, estamos interessados apenas no
tempo de execução. Dessa forma, faremos uma limpeza nos arquivos de
~log~, de maneira a mantermos apenas a informação referente ao tempo de
execução.

#+begin_src shell :results output :exports code :eval no-export
for file in `find . -name btmz*log`
do
    sed -n '/seconds/p' $file | sed 's/.*=//' > `basename $file`-time
done
#+end_src

#+RESULTS:

Após a limpeza, faremos uso da linguagem ~R~ para análise dos dados
observados nos experimentos. 

#+name: readingExpLogs
#+begin_src R :results output :exports both :session *R* :eval no-export
library(tidyverse)
library(dplyr)

options(crayon.enabled = FALSE)
options(pillar.sigfig=4)

expData <- 
    bind_rows(
        lapply(
            list.files(pattern = ".log-time"), 
            function(file){
                dt = 
                    read_csv(
                        file, 
                        trim_ws = TRUE, 
                        col_names = c("Time"), 
                        col_types = "d"
                    )
                dt$origin = 
                    sub('\\.log-time$', 
                        '', 
                        basename(file))
                dt %>% 
                    separate(origin, 
                             c("Application", 
                               "Run.No", 
                               "Threads", 
                               "Processes", 
                               "Class" ), 
                             sep = "-") %>%
                    select(Application, 
                           Run.No, 
                           Class, 
                           Processes, 
                           Threads, 
                           Time)
            }
        )
    ) 
expData
#+end_src

A partir de agora, podemos trabalhar somente na linguagem ~R~
diretamente com os dados que foram importados dos arquivos de ~log~ dos
experimentos. 

#+RESULTS: readingExpLogs
#+begin_example
# A tibble: 16 x 6
   Application Run.No Class Processes Threads   Time
   <chr>       <chr>  <chr> <chr>     <chr>    <dbl>
 1 btmz        1      A     2         2       20.45 
 2 btmz        10     W     2         1        3.35 
 3 btmz        11     A     1         2       23.18 
 4 btmz        12     W     2         2        2.280
 5 btmz        13     W     1         1        3.74 
 6 btmz        14     A     2         1       22.38 
 7 btmz        15     A     2         2       22.95 
 8 btmz        16     W     1         2        2.22 
 9 btmz        2      W     1         2        2.06 
10 btmz        3      A     1         2       26.04 
11 btmz        4      W     2         2        2.08 
12 btmz        5      W     2         1        2.030
13 btmz        6      W     1         1        3.75 
14 btmz        7      A     2         1       22.04 
15 btmz        8      A     1         1       40.36 
16 btmz        9      A     1         1       40.07
#+end_example

Como demonstração, faremos algumas computações estatísticas básicas
sobre os dados importados utilizando o pacote ~dplyr~ fornecido pelo
meta-pacote ~tidyverse~.  As execuções serão agrupadas por Classe,
número de processos e número de /threads/, possibilitando que sejam
calculadas a média, a mediana, o valor mínimo e o valor máximo das
observações do tempo de execução da aplicação.

#+name: avg
#+begin_src R :results output :exports both :session *R* :eval no-export

expData %>% 
    group_by(Application, Class, Processes, Threads) %>% 
    summarize(Mean = mean(Time), 
              Median = median(Time), 
              Min = min(Time), 
              Max = max(Time))
#+end_src

#+RESULTS: avg
#+begin_example
# A tibble: 8 x 8
# Groups:   Application, Class, Processes [?]
  Application Class Processes Threads   Mean Median    Min    Max
  <chr>       <chr> <chr>     <chr>    <dbl>  <dbl>  <dbl>  <dbl>
1 btmz        A     1         1       40.22  40.22  40.07  40.36 
2 btmz        A     1         2       24.61  24.61  23.18  26.04 
3 btmz        A     2         1       22.21  22.21  22.04  22.38 
4 btmz        A     2         2       21.7   21.7   20.45  22.95 
5 btmz        W     1         1        3.745  3.745  3.74   3.75 
6 btmz        W     1         2        2.14   2.14   2.06   2.22 
7 btmz        W     2         1        2.69   2.69   2.030  3.35 
8 btmz        W     2         2        2.180  2.180  2.08   2.280
#+end_example

Podemos calcular também o /speed-up/ das execuções mais rápidas sobre a
mais lenta, e então ordenar as observações do menor para o maior
/speed-up/.

/Speed-up/ das execuções com a classe A:
#+name: speedup-A
#+begin_src R :results output :exports both :session *R* :eval no-export
expData %>% 
    filter(Class == "A") %>%
    mutate(SpeedUp = max(Time)/Time) %>% 
    arrange(SpeedUp)
#+end_src

#+RESULTS:
#+begin_example
# A tibble: 8 x 7
  Application Run.No Class Processes Threads  Time SpeedUp
  <chr>       <chr>  <chr> <chr>     <chr>   <dbl>   <dbl>
1 btmz        8      A     1         1       40.36   1    
2 btmz        9      A     1         1       40.07   1.007
3 btmz        3      A     1         2       26.04   1.550
4 btmz        11     A     1         2       23.18   1.741
5 btmz        15     A     2         2       22.95   1.759
6 btmz        14     A     2         1       22.38   1.803
7 btmz        7      A     2         1       22.04   1.831
8 btmz        1      A     2         2       20.45   1.974
#+end_example

/Speed-up/ das execuções com a classe W:
#+name: speedup-W
#+begin_src R :results output :exports both :session *R* :eval no-export
expData %>% 
    filter(Class == "W") %>%
    mutate(SpeedUp = max(Time)/Time) %>% 
    arrange(SpeedUp)
#+end_src

#+RESULTS: speedup-W
#+begin_example
# A tibble: 8 x 7
  Application Run.No Class Processes Threads  Time SpeedUp
  <chr>       <chr>  <chr> <chr>     <chr>   <dbl>   <dbl>
1 btmz        6      W     1         1       3.75    1    
2 btmz        13     W     1         1       3.74    1.003
3 btmz        10     W     2         1       3.35    1.119
4 btmz        12     W     2         2       2.280   1.645
5 btmz        16     W     1         2       2.22    1.689
6 btmz        4      W     2         2       2.08    1.803
7 btmz        2      W     1         2       2.06    1.820
8 btmz        5      W     2         1       2.030   1.847
#+end_example

Podemos ainda verificar o /speed-up/ quando variamos apenas o número de
/threads/,

Classe A:
#+name: speedup-A-P1
#+begin_src R :results output :exports both :session *R* :eval no-export
expData %>% 
    filter(Class == "A", Processes == 1) %>%
    mutate(SpeedUp = max(Time)/Time) %>% 
    arrange(SpeedUp)
#+end_src

#+RESULTS: speedup-A-P1
: # A tibble: 4 x 7
:   Application Run.No Class Processes Threads  Time SpeedUp
:   <chr>       <chr>  <chr> <chr>     <chr>   <dbl>   <dbl>
: 1 btmz        8      A     1         1       40.36   1    
: 2 btmz        9      A     1         1       40.07   1.007
: 3 btmz        3      A     1         2       26.04   1.550
: 4 btmz        11     A     1         2       23.18   1.741

ou quando variamos apenas o número de processos.

Classe A:
#+name: speedup-A-T1
#+begin_src R :results output :exports both :session *R* :eval no-export
expData %>% 
    filter(Class == "A", Threads == 1) %>%
    mutate(SpeedUp = max(Time)/Time) %>% 
    arrange(SpeedUp)
#+end_src

#+RESULTS: speedup-A-T1
: # A tibble: 4 x 7
:   Application Run.No Class Processes Threads  Time SpeedUp
:   <chr>       <chr>  <chr> <chr>     <chr>   <dbl>   <dbl>
: 1 btmz        8      A     1         1       40.36   1    
: 2 btmz        9      A     1         1       40.07   1.007
: 3 btmz        14     A     2         1       22.38   1.803
: 4 btmz        7      A     2         1       22.04   1.831

* Local Variables                                                  :noexport:
# Local Variables:
# eval: (ox-extras-activate '(ignore-headlines))
# eval: (setq org-latex-listings t)
# eval: (setq org-latex-packages-alist '(("" "listings")))
# eval: (setq org-latex-packages-alist '(("" "listingsutf8")))
# eval: (setq ispell-local-dictionary "brasileiro")
# eval: (flyspell-mode t)
# End:
